"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseString = exports.parseWithdrawal = exports.parseDeposit = exports.parseOperator = exports.parseOperatorDetails = exports.parseDomain = exports.parseBalance = exports.parseBN = void 0;
const parseBN = (value) => BigInt(value.toString());
exports.parseBN = parseBN;
const parseBalance = (data) => {
    try {
        return {
            free: (0, exports.parseBN)(data.free),
            reserved: (0, exports.parseBN)(data.reserved),
            frozen: (0, exports.parseBN)(data.frozen),
            flags: (0, exports.parseBN)(data.flags),
        };
    }
    catch (error) {
        console.error('Error parsing balance:', error);
        throw new Error('Failed to parse balance');
    }
};
exports.parseBalance = parseBalance;
const parseDomain = (domain) => {
    const header = domain[0].toHuman();
    return Object.assign({ domainId: header[0] }, domain[1].toJSON());
};
exports.parseDomain = parseDomain;
const parseOperatorDetails = (operatorDetails) => {
    const rawOD = operatorDetails.toJSON();
    return {
        signingKey: rawOD.signingKey,
        currentDomainId: BigInt(rawOD.currentDomainId),
        nextDomainId: BigInt(rawOD.nextDomainId),
        minimumNominatorStake: BigInt(rawOD.minimumNominatorStake),
        nominationTax: rawOD.nominationTax,
        currentTotalStake: BigInt(rawOD.currentTotalStake),
        currentEpochRewards: BigInt(rawOD.currentEpochRewards),
        currentTotalShares: BigInt(rawOD.currentTotalShares),
        status: rawOD.status,
        depositsInEpoch: BigInt(rawOD.depositsInEpoch),
        withdrawalsInEpoch: BigInt(rawOD.withdrawalsInEpoch),
        totalStorageFeeDeposit: BigInt(rawOD.totalStorageFeeDeposit),
    };
};
exports.parseOperatorDetails = parseOperatorDetails;
const parseOperator = (operator) => {
    return {
        operatorId: BigInt(operator[0].toHuman()[0]),
        operatorDetails: (0, exports.parseOperatorDetails)(operator[1]),
    };
};
exports.parseOperator = parseOperator;
const parseDeposit = (deposit) => {
    const header = deposit[0].toHuman();
    const parsedDeposit = deposit[1].toJSON();
    const pending = parsedDeposit.pending !== null
        ? {
            effectiveDomainId: parsedDeposit.pending.effectiveDomainEpoch[0],
            effectiveDomainEpoch: parsedDeposit.pending.effectiveDomainEpoch[1],
            amount: BigInt(parsedDeposit.pending.amount),
            storageFeeDeposit: BigInt(parsedDeposit.pending.storageFeeDeposit),
        }
        : null;
    return {
        operatorId: parseInt(header[0]),
        account: header[1],
        shares: BigInt(parsedDeposit.known.shares.toString()),
        storageFeeDeposit: BigInt(parsedDeposit.known.storageFeeDeposit.toString()),
        known: {
            shares: BigInt(parsedDeposit.known.shares.toString()),
            storageFeeDeposit: BigInt(parsedDeposit.known.storageFeeDeposit.toString()),
        },
        pending,
    };
};
exports.parseDeposit = parseDeposit;
const parseWithdrawal = (withdrawal) => {
    const header = withdrawal[0].toHuman();
    const parsedWithdrawal = withdrawal[1].toJSON();
    return {
        operatorId: parseInt(header[0]),
        account: header[1],
        totalWithdrawalAmount: BigInt(parsedWithdrawal.totalWithdrawalAmount),
        withdrawalInShares: {
            domainEpoch: parsedWithdrawal.withdrawalInShares.domainEpoch,
            unlockAtConfirmedDomainBlockNumber: parsedWithdrawal.withdrawalInShares.unlockAtConfirmedDomainBlockNumber,
            shares: BigInt(parsedWithdrawal.withdrawalInShares.shares),
            storageFeeRefund: BigInt(parsedWithdrawal.withdrawalInShares.storageFeeRefund),
        },
        withdrawals: parsedWithdrawal.withdrawals &&
            parsedWithdrawal.withdrawals.length > 0 &&
            parsedWithdrawal.withdrawals.map((w) => ({
                domainId: w.domainId,
                unlockAtConfirmedDomainBlockNumber: w.unlockAtConfirmedDomainBlockNumber,
                amountToUnlock: BigInt(w.amountToUnlock),
                storageFeeRefund: BigInt(w.storageFeeRefund),
            })),
    };
};
exports.parseWithdrawal = parseWithdrawal;
const parseString = (operatorId) => typeof operatorId === 'string' ? operatorId : operatorId.toString();
exports.parseString = parseString;
